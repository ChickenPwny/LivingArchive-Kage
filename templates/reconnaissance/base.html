<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Reconnaissance{% endblock %} - EgoQT</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%);
            min-height: 100vh;
            color: #e2e8f0;
        }
        
        .navbar {
            background: rgba(15, 23, 42, 0.95);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #3b82f6;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .navbar h1 {
            color: #3b82f6;
            font-size: 1.5rem;
        }
        
        .navbar-links {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .nav-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 0 10px;
        }
        
        .nav-group-label {
            color: #64748b;
            font-size: 0.85rem;
            font-weight: 600;
            margin-right: 5px;
        }
        
        .nav-separator {
            color: #475569;
            margin: 0 5px;
        }
        
        .navbar-links a {
            color: #94a3b8;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .navbar-links a:hover, .navbar-links a.active {
            color: white;
            background: #3b82f6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px;
        }
        
        .page-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .page-header .icon {
            font-size: 3rem;
        }
        
        .page-header h2 {
            font-size: 2rem;
            color: white;
        }
        
        .page-header .subtitle {
            color: #94a3b8;
            margin-top: 5px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #334155;
        }
        
        .stat-card .label {
            color: #94a3b8;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        
        .stat-card .value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-color, #3b82f6);
        }
        
        .data-table {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #334155;
        }
        
        .data-table table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .data-table th {
            background: rgba(15, 23, 42, 0.8);
            padding: 15px;
            text-align: left;
            color: #94a3b8;
            font-weight: 600;
            border-bottom: 1px solid #334155;
        }
        
        .data-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #1e293b;
        }
        
        .data-table tr:hover {
            background: rgba(59, 130, 246, 0.1);
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .status-badge.success { background: #10b981; color: white; }
        .status-badge.warning { background: #f59e0b; color: black; }
        .status-badge.error { background: #ef4444; color: white; }
        .status-badge.info { background: #3b82f6; color: white; }
        
        .error-message {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            padding: 15px;
            border-radius: 8px;
            color: #fca5a5;
            margin-bottom: 20px;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #3b82f6;
            text-decoration: none;
            margin-bottom: 20px;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .json-cell {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-family: monospace;
            font-size: 0.85rem;
            color: #94a3b8;
        }
        
        /* Reconnaissance Team Control Header */
        .recon-control-header {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
            border-bottom: 2px solid #ec4899;
            padding: 15px 30px;
            margin-bottom: 0;
        }
        
        .recon-control-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .recon-control-title h3 {
            color: #ec4899;
            font-size: 1.1rem;
            margin: 0;
        }
        
        .recon-team-status {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .team-status-indicators {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .team-status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 20px;
            border: 1px solid rgba(236, 72, 153, 0.3);
        }
        
        .personality-icon {
            font-size: 1.2rem;
        }
        
        .team-status-item .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #64748b;
            animation: pulse 2s infinite;
        }
        
        .team-status-item .status-dot.running {
            background: #10b981;
            box-shadow: 0 0 8px #10b981;
        }
        
        .team-status-item .status-dot.paused {
            background: #f59e0b;
            box-shadow: 0 0 8px #f59e0b;
        }
        
        .team-status-item .status-dot.stopped {
            background: #ef4444;
        }
        
        .team-status-item .status-text {
            font-size: 0.85rem;
            color: #94a3b8;
            min-width: 60px;
        }
        
        .team-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .team-controls .control-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            min-width: 140px;
        }
        
        .team-controls .start-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .team-controls .start-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }
        
        .team-controls .pause-btn {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }
        
        .team-controls .pause-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }
        
        .team-controls .kill-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }
        
        .team-controls .kill-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }
        
        .team-controls .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .egg-selector-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .egg-selector-controls select,
        .egg-selector-controls input[type="text"] {
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #3b82f6;
            background: rgba(15, 23, 42, 0.8);
            color: white;
            font-size: 0.95rem;
        }
        
        .egg-selector-controls select {
            min-width: 300px;
            cursor: pointer;
        }
        
        .egg-selector-controls input[type="text"] {
            width: 200px;
        }
        
        .egg-selector-controls .queue-btn:hover {
            background: #7c3aed !important;
        }
        
        #egg-queue-status {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            min-width: 150px;
            text-align: center;
            transition: all 0.3s;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        {% block extra_styles %}{% endblock %}
    </style>
</head>
<body>
    <nav class="navbar">
        <h1>üîç Reconnaissance Team</h1>
        <div class="navbar-links">
            <a href="/" title="Home">üè† Home</a>
            <a href="/reconnaissance/general/" class="{% if personality == 'general' %}active{% endif %}">üîç General</a>
            <span class="nav-separator">|</span>
            <a href="/reconnaissance/kage/" class="{% if personality == 'kage' %}active{% endif %}">üîç PortScanner</a>
            <span class="nav-separator">|</span>
            <a href="/reconnaissance/eggrecords/" class="{% if personality == 'eggrecords' %}active{% endif %}">ü•ö EggRecords</a>
        </div>
    </nav>
    
    <!-- Reconnaissance Team Control Panel -->
    <div class="recon-control-header">
        <div class="recon-control-title">
            <span style="color: #ec4899; font-size: 1.2rem;">üéÄ</span>
            <h3>PortScanner Controls</h3>
        </div>
        <div class="recon-team-status">
            <div class="team-status-indicators">
                <div class="team-status-item">
                    <span class="personality-icon">üîç</span>
                    <span class="status-dot" id="kage-status-dot"></span>
                    <span class="status-text" id="kage-status-text">Unknown</span>
                </div>
            </div>
            <div class="egg-selector-controls" style="display: flex; align-items: center; gap: 10px; margin-right: 15px;">
                <select id="eggrecord-select" style="
                    padding: 10px 15px;
                    border-radius: 8px;
                    border: 2px solid #3b82f6;
                    background: rgba(15, 23, 42, 0.8);
                    color: white;
                    font-size: 0.95rem;
                    min-width: 300px;
                    cursor: pointer;
                " onchange="updateEggStatus()">
                    <option value="">üîç Search or select an Egg (parent)...</option>
                </select>
                <input type="text" id="eggrecord-search" placeholder="Type to search..." style="
                    padding: 10px 15px;
                    border-radius: 8px;
                    border: 2px solid #3b82f6;
                    background: rgba(15, 23, 42, 0.8);
                    color: white;
                    font-size: 0.95rem;
                    width: 200px;
                " oninput="searchEggrecords(this.value)">
                <button class="control-btn queue-btn" onclick="queueSelectedEgg()" style="
                    padding: 10px 20px;
                    background: #8b5cf6;
                    border: none;
                    border-radius: 8px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    transition: background 0.3s;
                " title="Queue selected egg for processing">
                    üìã Queue Egg
                </button>
                <div id="egg-queue-status" style="
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-size: 0.85rem;
                    min-width: 150px;
                    text-align: center;
                "></div>
            </div>
            <div class="team-controls">
                <button class="control-btn start-btn" onclick="controlAllPersonalities('start', true)" title="Start All - Scans entire database">
                    ‚ñ∂Ô∏è Start All
                </button>
                <button class="control-btn pause-btn" onclick="controlAllPersonalities('pause')" title="Pause/Resume All">
                    ‚è∏Ô∏è Pause All
                </button>
                <button class="control-btn kill-btn" onclick="controlAllPersonalities('kill')" title="Stop All">
                    ‚èπÔ∏è Kill All
                </button>
            </div>
        </div>
    </div>
    
    <div class="container">
        {% block content %}{% endblock %}
    </div>
    
    {% block scripts %}{% endblock %}
    
    <script>
    // Reconnaissance Team Control Functions
    const personalities = ['kage']; // Demo version - kage only
    
    // Check status for all personalities
    async function checkPersonalityStatus(personality) {
        try {
            const response = await fetch(`/reconnaissance/api/${personality}/status/`);
            const data = await response.json();
            if (data.success) {
                updatePersonalityStatus(personality, data.status);
            }
        } catch (error) {
            console.error(`Error checking ${personality} status:`, error);
            updatePersonalityStatus(personality, 'unknown');
        }
    }
    
    function updatePersonalityStatus(personality, status) {
        const statusDot = document.getElementById(`${personality}-status-dot`);
        const statusText = document.getElementById(`${personality}-status-text`);
        
        if (!statusDot || !statusText) return;
        
        statusDot.className = 'status-dot';
        
        switch(status) {
            case 'running':
                statusDot.classList.add('running');
                statusText.textContent = 'Running';
                break;
            case 'paused':
                statusDot.classList.add('paused');
                statusText.textContent = 'Paused';
                break;
            case 'stopped':
                statusDot.classList.add('stopped');
                statusText.textContent = 'Stopped';
                break;
            default:
                statusText.textContent = 'Unknown';
        }
    }
    
        async function controlAllPersonalities(action, scanAll = false) {
        const buttons = document.querySelectorAll('.team-controls .control-btn');
        buttons.forEach(btn => btn.disabled = true);
        
        let successCount = 0;
        let errorCount = 0;
        
        // Control all personalities in parallel
        const promises = personalities.map(async (personality) => {
            try {
                const response = await fetch(`/reconnaissance/api/${personality}/${action}/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({ scan_all: scanAll }),
                });
                
                const data = await response.json();
                
                // Always update status, even on error, so UI reflects actual state
                if (data.status) {
                    updatePersonalityStatus(personality, data.status);
                } else {
                    // If no status provided, check current status
                    updatePersonalityStatus(personality, 'unknown');
                }
                
                if (data.success) {
                    successCount++;
                } else {
                    console.error(`${personality} ${action} failed:`, data.error || data.message);
                    errorCount++;
                }
            } catch (error) {
                console.error(`Error controlling ${personality}:`, error);
                updatePersonalityStatus(personality, 'unknown');
                errorCount++;
            }
        });
        
        await Promise.all(promises);
        
        // Show notification with details
        if (errorCount === 0) {
            showNotification(`All personalities ${action} command sent successfully!`, 'success');
        } else if (successCount > 0) {
            showNotification(`${successCount} succeeded, ${errorCount} failed. Check console for details.`, 'error');
        } else {
            showNotification(`Failed to ${action} all personalities. Check console for details.`, 'error');
        }
        
        buttons.forEach(btn => btn.disabled = false);
        
        // Refresh status after a delay
        setTimeout(() => {
            personalities.forEach(personality => {
                checkPersonalityStatus(personality);
            });
        }, 1000);
    }
    
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    // Egg Selector Functions with localStorage caching
    const EGGS_CACHE_KEY = 'reconnaissance_eggs_cache';
    const EGGS_CACHE_TIMESTAMP_KEY = 'reconnaissance_eggs_cache_timestamp';
    const EGGS_CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
    
    let searchTimeout = null;
    let eggrecordsCache = [];
    
    // Load eggs from localStorage cache
    function loadEggsFromCache() {
        try {
            const cached = localStorage.getItem(EGGS_CACHE_KEY);
            const timestamp = localStorage.getItem(EGGS_CACHE_TIMESTAMP_KEY);
            
            if (cached && timestamp) {
                const age = Date.now() - parseInt(timestamp);
                if (age < EGGS_CACHE_DURATION) {
                    return JSON.parse(cached);
                } else {
                    // Cache expired, clear it
                    localStorage.removeItem(EGGS_CACHE_KEY);
                    localStorage.removeItem(EGGS_CACHE_TIMESTAMP_KEY);
                }
            }
        } catch (e) {
            console.warn('Error loading eggs from cache:', e);
        }
        return null;
    }
    
    // Save eggs to localStorage cache
    function saveEggsToCache(eggs) {
        try {
            localStorage.setItem(EGGS_CACHE_KEY, JSON.stringify(eggs));
            localStorage.setItem(EGGS_CACHE_TIMESTAMP_KEY, Date.now().toString());
            console.log(`Cached ${eggs.length} eggs to localStorage`);
        } catch (e) {
            console.warn('Error saving eggs to cache:', e);
        }
    }
    
    // Populate dropdown from eggs array
    function populateDropdownFromEggs(eggs, select) {
        select.innerHTML = '<option value="">Select an egg...</option>';
        
        if (eggs && eggs.length > 0) {
            eggs.forEach(egg => {
                const option = document.createElement('option');
                option.value = egg.id;
                // Just show domainname (project name) - no ID clutter
                option.textContent = egg.domainname || 'Unknown';
                option.dataset.domainname = egg.domainname;
                select.appendChild(option);
            });
            console.log(`‚úÖ Populated dropdown with ${eggs.length} eggs`);
        } else {
            select.innerHTML = '<option value="">No eggs available</option>';
            console.warn('No eggs to populate in dropdown');
        }
    }
    
    async function searchEggrecords(query) {
        clearTimeout(searchTimeout);
        const select = document.getElementById('eggrecord-select');
        
        // If query is empty, reload all eggs from cache or server
        if (!query || query.trim() === '') {
            loadInitialEggs();
            return;
        }
        
        // If query is too short, show message but don't search yet
        if (query.length < 2) {
            select.innerHTML = '<option value="">üîç Type at least 2 characters to search eggs...</option>';
            return;
        }
        
        // Try cache first
        const cachedEggs = loadEggsFromCache();
        if (cachedEggs) {
            const filtered = cachedEggs.filter(egg => 
                egg.domainname && egg.domainname.toLowerCase().includes(query.toLowerCase())
            );
            if (filtered.length > 0) {
                populateDropdownFromEggs(filtered, select);
                return;
            }
        }
        
        // If not in cache or no matches, search server
        searchTimeout = setTimeout(async () => {
            try {
                const response = await fetch(`/reconnaissance/api/eggs/search/?q=${encodeURIComponent(query)}&limit=200`);
                const data = await response.json();
                
                if (data.success && data.eggs) {
                    eggrecordsCache = data.eggs;
                    populateDropdownFromEggs(data.eggs, select);
                } else {
                    // Try cache as fallback
                    const cached = loadEggsFromCache();
                    if (cached) {
                        const filtered = cached.filter(egg => 
                            egg.domainname && egg.domainname.toLowerCase().includes(query.toLowerCase())
                        );
                        populateDropdownFromEggs(filtered, select);
                    } else {
                        console.error('API error:', data.error);
                        select.innerHTML = '<option value="">Error: ' + (data.error || 'Unknown error') + ' (using cache)</option>';
                    }
                }
            } catch (error) {
                console.error('Error searching eggs:', error);
                // Try cache as fallback
                const cached = loadEggsFromCache();
                if (cached) {
                    const filtered = cached.filter(egg => 
                        egg.domainname && egg.domainname.toLowerCase().includes(query.toLowerCase())
                    );
                    populateDropdownFromEggs(filtered, select);
                } else {
                    select.innerHTML = '<option value="">Error searching: ' + error.message + '</option>';
                }
            }
        }, 300);
    }
    
    async function updateEggStatus() {
        const select = document.getElementById('eggrecord-select');
        const statusDiv = document.getElementById('egg-queue-status');
        const eggId = select.value;
        
        if (!eggId) {
            statusDiv.innerHTML = '';
            statusDiv.style.background = '';
            return;
        }
        
        try {
            const response = await fetch(`/reconnaissance/api/eggs/${eggId}/queue-status/`);
            const data = await response.json();
            
            if (data.success) {
                const status = data.status;
                let statusText = [];
                let hasQueue = false;
                
                for (const [personality, info] of Object.entries(status)) {
                    if (info.queued) {
                        hasQueue = true;
                        statusText.push(`${personality}: ${info.queued_count}/${info.total_eggrecords} queued`);
                    }
                }
                
                if (hasQueue) {
                    statusDiv.innerHTML = `‚úÖ ${statusText.join(', ')}`;
                    statusDiv.style.background = 'rgba(16, 185, 129, 0.2)';
                    statusDiv.style.color = '#10b981';
                } else {
                    statusDiv.innerHTML = `Not queued (${data.status.kage?.total_eggrecords || 0} eggrecords)`;
                    statusDiv.style.background = 'rgba(100, 116, 139, 0.2)';
                    statusDiv.style.color = '#64748b';
                }
            }
        } catch (error) {
            console.error('Error checking queue status:', error);
            statusDiv.innerHTML = 'Error';
            statusDiv.style.background = 'rgba(239, 68, 68, 0.2)';
            statusDiv.style.color = '#ef4444';
        }
    }
    
    async function queueSelectedEgg() {
        const select = document.getElementById('eggrecord-select');
        const eggId = select.value;
        const statusDiv = document.getElementById('egg-queue-status');
        
        if (!eggId) {
            showNotification('Please select an egg first', 'error');
            return;
        }
        
        const domainname = select.options[select.selectedIndex].dataset.domainname;
        
        // Queue for all personalities
        const personalities = ['kage']; // Demo version - kage only
        let successCount = 0;
        let errorCount = 0;
        let totalQueued = 0;
        
        statusDiv.innerHTML = '‚è≥ Queueing all eggrecords...';
        statusDiv.style.background = 'rgba(59, 130, 246, 0.2)';
        statusDiv.style.color = '#3b82f6';
        
        for (const personality of personalities) {
            try {
                const commandType = 'scan'; // Demo version - kage only uses scan
                const response = await fetch('/reconnaissance/api/eggs/queue/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        egg_id: eggId,
                        personality: personality,
                        command_type: commandType
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    successCount++;
                    totalQueued += data.queued_count || 0;
                } else {
                    errorCount++;
                }
            } catch (error) {
                console.error(`Error queueing for ${personality}:`, error);
                errorCount++;
            }
        }
        
        if (successCount > 0) {
            showNotification(`Queued ${totalQueued} eggrecords across ${successCount} personality/personalities`, 'success');
            updateEggStatus(); // Refresh status
        } else {
            showNotification('Failed to queue egg', 'error');
            statusDiv.innerHTML = '‚ùå Failed';
            statusDiv.style.background = 'rgba(239, 68, 68, 0.2)';
            statusDiv.style.color = '#ef4444';
        }
    }
    
    function showNotification(message, type) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
            ${type === 'success' ? 'background: #10b981;' : 'background: #ef4444;'}
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease-out';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }
    
    // Check status for all personalities on page load
    personalities.forEach(personality => {
        checkPersonalityStatus(personality);
    });
    
    // Load initial eggs on page load (from cache first, then server)
    async function loadInitialEggs() {
        const select = document.getElementById('eggrecord-select');
        if (!select) {
            console.error('Egg select dropdown not found');
            return;
        }
        
        // Try cache first
        const cachedEggs = loadEggsFromCache();
        if (cachedEggs && cachedEggs.length > 0) {
            console.log(`Loading ${cachedEggs.length} eggs from cache`);
            populateDropdownFromEggs(cachedEggs, select);
            eggrecordsCache = cachedEggs;
            
            // Refresh from server in background (non-blocking)
            refreshEggsFromServer();
            return;
        }
        
        // No cache, load from server
        select.innerHTML = '<option value="">‚è≥ Loading eggs...</option>';
        await refreshEggsFromServer();
    }
    
    // Refresh eggs from server and update cache
    async function refreshEggsFromServer() {
        try {
            const response = await fetch('/reconnaissance/api/eggs/search/');
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            console.log('Eggs API response:', data);
            
            if (data.success && data.eggs && Array.isArray(data.eggs) && data.eggs.length > 0) {
                // Save to cache
                saveEggsToCache(data.eggs);
                eggrecordsCache = data.eggs;
                
                // Always update dropdown with fresh data
                const select = document.getElementById('eggrecord-select');
                if (select) {
                    populateDropdownFromEggs(data.eggs, select);
                }
                
                console.log(`‚úÖ Loaded ${data.eggs.length} eggs from server and cached`);
            } else {
                console.warn('API returned no eggs or error:', data);
                // Server returned cached/error response, use existing cache if available
                const cached = loadEggsFromCache();
                if (cached && cached.length > 0) {
                    console.log('Server unavailable, using cached eggs');
                    const select = document.getElementById('eggrecord-select');
                    if (select) {
                        populateDropdownFromEggs(cached, select);
                    }
                } else {
                    const select = document.getElementById('eggrecord-select');
                    if (select) {
                        select.innerHTML = '<option value="">‚ö†Ô∏è No eggs available (database may be down)</option>';
                    }
                }
            }
        } catch (error) {
            console.error('Error refreshing eggs from server:', error);
            // Try to use cache as fallback
            const cached = loadEggsFromCache();
            if (cached && cached.length > 0) {
                console.log('Server error, using cached eggs');
                const select = document.getElementById('eggrecord-select');
                if (select) {
                    populateDropdownFromEggs(cached, select);
                }
            } else {
                const select = document.getElementById('eggrecord-select');
                if (select) {
                    select.innerHTML = '<option value="">‚ö†Ô∏è Error loading eggs: ' + error.message + '</option>';
                }
            }
        }
    }
    
    // Load eggs when page loads (wait for DOM to be ready)
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadInitialEggs);
    } else {
        loadInitialEggs();
    }
    
    // Refresh status every 5 seconds
    setInterval(() => {
        personalities.forEach(personality => {
            checkPersonalityStatus(personality);
        });
    }, 5000);
    </script>
</body>
</html>

