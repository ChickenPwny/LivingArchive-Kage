#!/usr/bin/env python3
"""
WAF Fingerprinting Module
==========================

Detects and fingerprints WAFs using multiple techniques:
- Response header analysis
- Block page patterns
- Timing analysis
- TTL fingerprinting
- Challenge-response patterns
"""

import re
import time
import socket
import requests
import warnings
import urllib3
from typing import Dict, Any, Optional, List
from urllib.parse import urlparse
import logging

# Suppress urllib3 SSL warnings - we detect and report SSL issues separately
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

logger = logging.getLogger(__name__)


class WAFFingerprinter:
    """Fingerprint WAFs using multiple detection techniques."""
    
    # WAF signatures (headers, response patterns, etc.)
    WAF_SIGNATURES = {
        'cloudflare': {
            'headers': ['cf-ray', 'cf-request-id', 'server'],
            'header_patterns': [r'cloudflare', r'cf-'],
            'response_patterns': [r'checking your browser', r'cf-browser-verification'],
            'status_codes': [403, 503],
            'ttl_pattern': None
        },
        'aws_waf': {
            'headers': ['x-amzn-requestid', 'x-amzn-trace-id'],
            'header_patterns': [r'aws', r'amazon'],
            'response_patterns': [r'aws waf', r'request blocked'],
            'status_codes': [403],
            'ttl_pattern': None
        },
        'akamai': {
            'headers': ['akamai-request-id', 'x-akamai-transformed'],
            'header_patterns': [r'akamai'],
            'response_patterns': [r'akamai', r'access denied'],
            'status_codes': [403],
            'ttl_pattern': None
        },
        'imperva': {
            'headers': ['x-iinfo', 'x-cdn'],
            'header_patterns': [r'imperva', r'incapsula'],
            'response_patterns': [r'imperva', r'incapsula', r'request unsuccessful'],
            'status_codes': [403, 406],
            'ttl_pattern': None
        },
        'sucuri': {
            'headers': ['x-sucuri-id', 'x-sucuri-cache'],
            'header_patterns': [r'sucuri'],
            'response_patterns': [r'sucuri', r'access denied'],
            'status_codes': [403],
            'ttl_pattern': None
        },
        'barracuda': {
            'headers': ['barracuda'],
            'header_patterns': [r'barracuda'],
            'response_patterns': [r'barracuda', r'blocked'],
            'status_codes': [403],
            'ttl_pattern': None
        },
        'fortinet': {
            'headers': ['fortigate'],
            'header_patterns': [r'fortinet', r'fortigate'],
            'response_patterns': [r'fortinet', r'fortigate'],
            'status_codes': [403],
            'ttl_pattern': None
        },
        'f5_bigip': {
            'headers': ['x-f5-new-ssl-session-id', 'x-f5-application'],
            'header_patterns': [r'f5', r'bigip'],
            'response_patterns': [r'f5', r'bigip'],
            'status_codes': [403],
            'ttl_pattern': None
        },
        'mod_security': {
            'headers': [],
            'header_patterns': [],
            'response_patterns': [r'mod_security', r'this error was generated by mod_security'],
            'status_codes': [403],
            'ttl_pattern': None
        },
        'wordfence': {
            'headers': ['x-wf-protection'],
            'header_patterns': [r'wordfence'],
            'response_patterns': [r'wordfence', r'generated by wordfence'],
            'status_codes': [403],
            'ttl_pattern': None
        }
    }
    
    def __init__(self):
        self.detection_history = []
    
    def fingerprint_waf(self, target: str, response: Optional[requests.Response] = None, 
                       probe_result: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Fingerprint WAF using multiple techniques.
        
        Args:
            target: Target hostname or IP
            response: HTTP response object (if available)
            probe_result: Result from host discovery probe
            
        Returns:
            Dictionary with WAF detection results
        """
        result = {
            'waf_detected': False,
            'waf_type': None,
            'confidence': 0.0,
            'detection_methods': [],
            'signatures': {},
            'bypass_recommendations': []
        }
        
        # Method 1: Header analysis
        if response:
            header_result = self._analyze_headers(response.headers)
            if header_result['waf_detected']:
                result['waf_detected'] = True
                result['waf_type'] = header_result['waf_type']
                result['confidence'] = max(result['confidence'], header_result['confidence'])
                result['detection_methods'].append('headers')
                result['signatures']['headers'] = header_result['signatures']
        
        # Method 2: Response body analysis
        if response:
            body_result = self._analyze_response_body(response.text, response.status_code)
            if body_result['waf_detected']:
                result['waf_detected'] = True
                if not result['waf_type']:
                    result['waf_type'] = body_result['waf_type']
                result['confidence'] = max(result['confidence'], body_result['confidence'])
                result['detection_methods'].append('response_body')
                result['signatures']['body'] = body_result['signatures']
        
        # Method 3: Timing analysis
        if probe_result:
            timing_result = self._analyze_timing(probe_result)
            if timing_result['waf_detected']:
                result['waf_detected'] = True
                if not result['waf_type']:
                    result['waf_type'] = timing_result['waf_type']
                result['confidence'] = max(result['confidence'], timing_result['confidence'] * 0.7)  # Lower confidence for timing
                result['detection_methods'].append('timing')
        
        # Method 4: TTL fingerprinting
        if probe_result:
            ttl_result = self._analyze_ttl(target, probe_result)
            if ttl_result['waf_detected']:
                result['waf_detected'] = True
                if not result['waf_type']:
                    result['waf_type'] = ttl_result['waf_type']
                result['confidence'] = max(result['confidence'], ttl_result['confidence'] * 0.6)
                result['detection_methods'].append('ttl')
        
        # Generate bypass recommendations
        if result['waf_detected']:
            result['bypass_recommendations'] = self._get_bypass_recommendations(result['waf_type'])
        
        return result
    
    def _analyze_headers(self, headers: Dict[str, str]) -> Dict[str, Any]:
        """Analyze HTTP headers for WAF signatures."""
        result = {
            'waf_detected': False,
            'waf_type': None,
            'confidence': 0.0,
            'signatures': {}
        }
        
        headers_lower = {k.lower(): v.lower() for k, v in headers.items()}
        
        for waf_type, signatures in self.WAF_SIGNATURES.items():
            score = 0.0
            found_signatures = []
            
            # Check header names
            for header_name in signatures.get('headers', []):
                if header_name.lower() in headers_lower:
                    score += 0.5
                    found_signatures.append(f"header:{header_name}")
            
            # Check header patterns
            for pattern in signatures.get('header_patterns', []):
                for header_name, header_value in headers_lower.items():
                    if re.search(pattern, header_name) or re.search(pattern, header_value):
                        score += 0.3
                        found_signatures.append(f"pattern:{pattern}")
            
            # Check status code
            status_code = headers.get('status_code') or headers.get('status')
            if status_code and int(status_code) in signatures.get('status_codes', []):
                score += 0.2
            
            if score > 0.5:  # Threshold for detection
                result['waf_detected'] = True
                result['waf_type'] = waf_type
                result['confidence'] = min(score, 1.0)
                result['signatures'] = found_signatures
                break
        
        return result
    
    def _analyze_response_body(self, body: str, status_code: int) -> Dict[str, Any]:
        """Analyze response body for WAF block pages."""
        result = {
            'waf_detected': False,
            'waf_type': None,
            'confidence': 0.0,
            'signatures': {}
        }
        
        body_lower = body.lower()
        
        for waf_type, signatures in self.WAF_SIGNATURES.items():
            score = 0.0
            found_signatures = []
            
            # Check response patterns
            for pattern in signatures.get('response_patterns', []):
                if re.search(pattern, body_lower, re.IGNORECASE):
                    score += 0.4
                    found_signatures.append(f"body_pattern:{pattern}")
            
            # Check status code
            if status_code in signatures.get('status_codes', []):
                score += 0.3
            
            if score > 0.5:
                result['waf_detected'] = True
                result['waf_type'] = waf_type
                result['confidence'] = min(score, 1.0)
                result['signatures'] = found_signatures
                break
        
        return result
    
    def _analyze_timing(self, probe_result: Dict) -> Dict[str, Any]:
        """Analyze response timing for WAF detection."""
        result = {
            'waf_detected': False,
            'waf_type': None,
            'confidence': 0.0
        }
        
        # WAFs typically add 50-200ms latency
        response_time = probe_result.get('response_time_ms', 0)
        if 50 < response_time < 500:  # Suspicious timing
            result['waf_detected'] = True
            result['waf_type'] = 'unknown'  # Can't determine type from timing alone
            result['confidence'] = 0.5
        
        return result
    
    def _analyze_ttl(self, target: str, probe_result: Dict) -> Dict[str, Any]:
        """Analyze TTL for WAF detection."""
        result = {
            'waf_detected': False,
            'waf_type': None,
            'confidence': 0.0
        }
        
        # WAFs often have different TTL than origin
        # This requires multiple probes to compare
        # For now, return basic detection
        return result
    
    def _get_bypass_recommendations(self, waf_type: str) -> List[str]:
        """Get bypass recommendations based on WAF type."""
        recommendations = {
            'cloudflare': [
                'Use TCP SYN to non-HTTP ports (22, 25, 53)',
                'Try UDP DNS probes (port 53)',
                'Use TCP ACK ping (appears as established connection)',
                'Fragment packets to bypass inspection',
                'Use IP protocol ping (ICMP)'
            ],
            'aws_waf': [
                'Use TCP SYN to non-standard ports',
                'Try UDP probes',
                'Use source port manipulation',
                'Fragment packets',
                'Slow scan timing (-T2)'
            ],
            'akamai': [
                'Use TCP ACK ping',
                'Try UDP DNS probes',
                'Use non-HTTP ports',
                'Fragment packets'
            ],
            'imperva': [
                'Use TCP SYN to non-HTTP ports',
                'Try UDP probes',
                'Use source port 53 (DNS)',
                'Fragment packets'
            ],
            'default': [
                'Use TCP SYN to non-HTTP ports',
                'Try TCP ACK ping',
                'Use UDP DNS probes (port 53)',
                'Use ICMP ping',
                'Fragment packets',
                'Slow scan timing'
            ]
        }
        
        return recommendations.get(waf_type, recommendations['default'])


